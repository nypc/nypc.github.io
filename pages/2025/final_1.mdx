import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "기호",
  year: 2025,
  stage: "본선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

`+` (덧셈 기호)와 `-` (뺄셈 기호)로 구성된 문자열이 주어진다.
문자열은 아래의 규칙을 만족해야 한다.

* 규칙: 문자열에서 어떤 앞부분을 보아도 `-`의 개수가 `+`의 개수보다 많으면 안된다.

예를 들어, 문자열 `+-+-`는 규칙을 만족하지만,
문자열 `+--+`는 규칙을 만족하지 않는다.
왜냐하면, 문자열 `+--+`에서 길이가 $3$인 앞부분은 `+--`인데,
`-`의 개수가 $2$로 `+`의 개수 $1$보다 많기 때문이다.

주어진 문자열이 규칙을 만족하도록 만들기 위해
문자열에서 바꿔야 하는 글자의 개수의 최솟값을 계산하는 프로그램을 작성하라.
글자를 새로 추가하거나 제거할 수는 없고,
`+`를 `-`로 또는 `-`를 `+`로 바꾸는 것만 허용된다는 것에 주의하라.

## 입력 형식

첫 줄에 문자열의 길이를 나타내는 정수 $N$이 주어진다.
$(1 \le N \le 200\,000)$

그다음 줄에 문자열이 주어진다.
이 문자열의 길이는 $N$이고 `+`와 `-`로만 구성되어 있다.

## 출력 형식

첫 줄에 문자열이 규칙을 만족하도록 만들기 위해 바꿔야 하는 최소 글자 수를 출력한다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
3
+-+
  </Input>
  {/* prettier-ignore */}
  <Output>
0
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
1
\-
  </Input>
  {/* prettier-ignore */}
  <Output>
1
  </Output>
</Examples>

## 예제 3

<Examples>
  {/* prettier-ignore */}
  <Input>
4
\+--+
  </Input>
  {/* prettier-ignore */}
  <Output>
1
  </Output>
</Examples>

## 예제 설명

예제 1의 경우,
주어진 문자열 `+-+`가 이미 규칙을 만족하므로 글자를 바꿀 필요가 없다.

예제 2의 경우,
주어진 문자열 `-`를 `+`로 바꾸면 규칙을 만족한다.

예제 3의 경우,
두 번째 글자 `-`를 `+`로 바꾸어 문자열을 `++-+`로 만들거나,
세 번째 글자 `-`를 `+`로 바꾸어 문자열을 `+-++`로 만들면
규칙을 만족한다.

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={18}>
  $N \le 3$
</Subtask>
<Subtask index={2} score={23}>
  $N \le 2\,000$
</Subtask>
<Subtask index={3} score={59}>
  모든 입력 케이스가 주어진다.
</Subtask>

## 해설

<Solution>
문자열을 앞에서부터 차례대로 보면서, 뺄셈 기호의 수가 덧셈 기호의 수보다 커질 때마다 뺄셈 기호 하나를 덧셈 기호로 변경하면 항상 최소 횟수로 규칙을 만족하는 문자열을 만들 수 있습니다.
- Challenge: $i$번째 문자열을 변경하는 비용 $A_i$가 주어졌을 때, 최소 비용으로 규칙을 만족하는 문자열은 어떻게 만들 수 있을까요?
</Solution>
