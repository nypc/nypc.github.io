import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  bikoId: 5487,
  title: "버튼",
  year: 2025,
  stage: "Round 1",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

서로 구별되는 버튼 $N$개가 있는 자물쇠가 있다.
$N$개 중 서로 다른 $K$개의 버튼을 순서대로 누르면 자물쇠가 열린다.

자물쇠가 잠긴 상태에서 제대로 된 순서로 버튼을 누르면 버튼에 불이 들어와서
제대로 눌렀음을 알려 준다.
하지만, 한 번이라도 제대로 누르지 않으면 모든 불이 꺼지고
자물쇠는 리셋되어 잠긴 상태로 돌아간다.

자물쇠를 푸는 사람이 모든 것을 완벽히 기억하며 최선의 방법을 사용한다고 가정하자.
최선의 방법을 사용함에도 불구하고 버튼을 최대 몇 번까지 눌러야
자물쇠를 열 수 있는지 계산하는 프로그램을 작성하라.

## 입력 형식

첫 줄에 두 정수 $N$과 $K$가 공백으로 구분되어 주어진다.
($1 \le K \le N \le 1\,000\,000$)

## 출력 형식

첫 줄에 버튼을 눌러야 하는 횟수를 출력한다.

## 예제

<Examples>
  {/* prettier-ignore */}
  <Input>
4 2
  </Input>
  {/* prettier-ignore */}
  <Output>
9
  </Output>
</Examples>

## 예제 설명

첫 번째로 눌러야 하는 버튼을 알아내는 데 최악의 경우 $4$번을 눌러야 한다.
여기서, 두 번째로 눌러야 하는 버튼을 알아내기 위해서는,
매번 첫 번째 버튼을 다시 눌러야 한다는 점을 고려하면, $5$번의 누르기가 추가로 필요하다.
따라서 이 경우의 답은 $9$이다.

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={30}>
  $N \le 10$
</Subtask>
<Subtask index={2} score={20}>
  $N \le 5\,000$
</Subtask>
<Subtask index={3} score={33}>
  $K \le 3$
</Subtask>
<Subtask index={4} score={17}>
  모든 입력 케이스가 주어짐.
</Subtask>

## 해설

<Solution>
$i$번째로 눌러야 하는 버튼 후보의 개수는 $N-i+1$개입니다.

처음으로 시도하는 후보의 경우, 이미 $i-1$개의 버튼이 눌러져 있으므로, $1$번만 추가로 누르면 됩니다.

나머지 $N-i$개의 후보들은 처음부터 $i$개의 버튼을 눌러야 하므로,
$i$번째 버튼을 찾기 위해 눌러야 하는 총 횟수는 $i(N-i) + 1$입니다.

각 $1 \le i \le K$에 대해, $i(N-i)+1$의 합을 계산하면 정답을 구할 수 있습니다.
시간 복잡도는 $\mathcal{O}(K)$가 됩니다.
</Solution>
