import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  bikoId: 5630,
  title: "돌 무더기 게임",
  year: 2025,
  stage: "본선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

$3$개의 돌 무더기로 시작하는 게임이 있다.
게임은 두 명의 선수가 턴을 번갈아가며 진행한다.

현재 돌 무더기의 돌 개수가 각각 $a$, $b$, $c$라고 하자.
무더기의 돌 개수는 항상 $1$ 이상의 정수여야 한다.
현재 차례인 선수는 다음 과정을 진행한다:

1. 돌 무더기 중 하나를 제거한다. (돌 개수가 $a$인 무더기가 제거되었다고 하자.)
2. 남은 돌 무더기 중 하나를 두 개로 나눈다. 돌 개수가 $b$인 무더기를 돌 개수가 $b_1$, $b_2$인 두 개의 무더기로 나누었다고 하면 $b_1 + b_2 = b$이고 $b_1 > 0$, $b_2 > 0$을 만족해야 한다.

위 과정 중 **2.** 에서 만약 $b = 1$이라면
무더기를 나눌 수 없음에 주의하라.

현재 차례인 선수가 위의 과정을 진행하지 못하는 경우
해당 선수가 지고 다른 선수가 이긴다.

두 선수가 모두 최선을 다하는 경우 먼저 차례를 시작하는 선수(`first`)와
그다음에 차례가 되는 선수(`second`) 중
누가 이기는지 알아내는 프로그램을 작성하라.
지는 선수가 어떤 선택을 하더라도 이기는 선수가 반드시 이기는
적절한 선택이 존재해야 한다.

## 입력 형식

첫 줄에 테스트 케이스의 수를 나타내는 정수 $T$가 주어진다.
$(1 \le T \le 100\,000)$

그다음 $T$개의 줄에 걸쳐, 각 줄마다 하나의 테스트 케이스가 주어진다.
각 테스트 케이스는 최초 돌 무더기의 돌 개수를 나타내는 세 정수
$a$, $b$, $c$가 공백으로 구분되어 주어진다.
$(1 \le a, b, c \le 10^{18})$

## 출력 형식

각 테스트 케이스 별로 한 줄에,
먼저 차례를 시작하는 선수가 이기는 경우 `first`를,
그다음에 차례가 되는 선수가 이기는 경우 `second`를
출력한다.


## 예제

<Examples>
  {/* prettier-ignore */}
  <Input>
3
1 1 1
1 2 1
2 1 2
  </Input>
  {/* prettier-ignore */}
  <Output>
second
first
first
  </Output>
</Examples>

## 예제 설명

첫 테스트 케이스의 경우,
첫 차례에서 진행이 불가능하므로 그다음 차례를 받는 선수가 이긴다.

두 번째 테스트 케이스의 경우,
개수가 $1$인 무더기를 제거하고
개수가 $2$인 무더기를 개수가 각각 $1$인 무더기로 나누면,
그다음 차례에서 진행이 불가능하다.

세 번째 테스트 케이스의 경우,
개수가 $2$인 무더기 중 하나를 제거하고
개수가 $2$인 무더기를 개수가 각각 $1$인 무더기로 나누면,
그다음 차례에서 진행이 불가능하다.


## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={13}>
  $a, b, c \le 2$
</Subtask>
<Subtask index={2} score={11}>
  $a, b, c \le 4$
</Subtask>
<Subtask index={3} score={29}>
  $a, b, c \le 100$
</Subtask>
<Subtask index={4} score={42}>
  $a, b, c \le 1\,000\,000$
</Subtask>
<Subtask index={5} score={5}>
  모든 입력 케이스가 주어진다.
</Subtask>

## 해설

<Solution>
양의 정수 $x$가 홀수가 될 때까지 $2$로 반복해서 나눌 때, 총 나눠지는 횟수를 $f(x)$라고 정의합시다.
예를 들어, $f(1) = 0$, $f(5) = 0$, $f(2) = 1$, $f(12) = 2$ 입니다.

게임의 상태 $(a, b, c)$가 주어졌을 때, 현재 차례인 선수가 패배함은 $f(a) = f(b) = f(c)$와 동치입니다.
따라서, 각 테스트 케이스에 대해 $\mathcal{O} \left( \log \max \{ a, b, c \} \right)$에 해결할 수 있습니다.

증명은 이러합니다:
- 먼저, $f(a) = f(b) = f(c)$라면, $a = b = c = 1$로 이미 패배했거나, 일반성을 잃지 않고 $f(a) = f(b) < f(c)$인 상태로 상대에게 차례를 넘겨줍니다.
- 만약, $f(a) = f(b) = f(c)$가 아닌 상태라면, 일반성을 잃지 않고 $f(a) < f(b)$인 두 수 $a$, $b$를 잡을 수 있습니다. 즉, 돌 개수가 $c$인 돌 무더기를 제거한 후, 돌 개수가 $b$인 돌 무더기를 $b_1 + b_2 = b$ 이면서 $f(a) = f(b_1) = f(b_2)$가 되도록 나눌 수 있습니다. 차례가 지날수록 총 돌의 개수 $a + b + c$는 감소하므로, 위의 귀납법은 정당합니다
</Solution>
