import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "중복",
  year: 2025,
  stage: "Round 2-A",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

$N$개의 항을 가진 수열 $A$가 있다.
각 항에 $1$을 더하거나 빼는 연산을 수행할 수 있다.
같은 항에 연산을 여러 번 수행하는 것도 가능하다. 

최소한의 연산으로 수열 $A$에서 어떤 값 $X$가 $K$번 이상 등장하도록
만드는 프로그램을 작성하라.
$K$번 이상 등장하는 값이 $2$개 이상이어도 상관 없다.

## 입력 형식

첫 줄에 수열의 길이를 나타내는 정수 $N$과 정수 $K$가 주어진다.
($1 \le K \le N \le 300\,000$)

그다음 줄에 수열의 $N$개의 항의 초깃값이 공백으로 구분되어 차례대로 주어진다.
이 값은 모두 $-1\,000\,000\,000$ 이상 $1\,000\,000\,000$ 이하의 정수다.

## 출력 형식

첫 줄에 최소 연산 횟수를 출력한다.

## 예제

<Examples>
  {/* prettier-ignore */}
  <Input>
5 4
2 1 2 4 2
  </Input>
  {/* prettier-ignore */}
  <Output>
1
  </Output>
</Examples>

## 예제 설명

첫 번째 예제에서, 한 번의 연산으로 수열의 두 번째 값을 $2$로 바꾸면,
수열은 $[2, 2, 2, 4, 2]$가 되어 $2$가 $4$번 등장하게 된다.

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={13}>
  수열의 항의 초깃값은 모두 $1$ 이상 $100$ 이하이다.
</Subtask>
<Subtask index={2} score={26}>
  $N \le 3\,000$
</Subtask>
<Subtask index={3} score={61}>
  모든 입력 케이스가 주어진다.
</Subtask>

## 해설

<Solution>

입력된 수를 오름차순으로 정렬한 뒤 $[i, i+K)$ 구간을 모두 같은 값으로 만드는 전략을 사용할 것입니다.

오름차순으로 정렬된 $K$개의 수 $A_i, A_{i+1}, \cdots, A_{i+K-1}$을 모두 어떤 값 $X$로 만들기 위해서는 $f_i(X) = \vert A_i - X \vert + \vert A_{i+1} - X \vert + \cdots + \vert A_{i+K-1} - X \vert$ 만큼의 연산이 필요합니다. 함수 $f_i(x)$는 처음에는 계속 감소하다가 특정 지점 이후부터는 계속 증가하는 형태의 함수이며, 극소점을 갖는 지점은 $A_i, A_{i+1}, \cdots, A_{i+K-1}$의 중앙값입니다.

따라서 $K$개의 수를 그들의 중앙값, 다시 말해 $A_{\lfloor (2i+K-1)/2 \rfloor}$으로 만드는 것이 최적입니다. $f(A_{\lfloor (2i+K-1)/2 \rfloor})$를 총 $N-K+1$개의 구간에 대해 계산해야 하고, 이는 누적합 배열을 이용해 매번 상수 시간에 계산할 수 있습니다. 입력으로 주어진 수를 오름차순으로 정렬하는 데 $\mathcal{O}(N \log N)$, 이후 $f(\ast)$의 값을 계산하는 데 $\mathcal{O}(N)$ 만큼의 연산이 필요하므로 전체 시간 복잡도는 $\mathcal{O}(N \log N)$입니다.

</Solution>
