import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "마방진 만들기",
  year: 2025,
  stage: "본선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

**마방진**은 $N \times N$ 크기의 정사각형 칸에
$N \times N$개의 수를 한 칸에 하나씩 배열하여,
가로, 세로, 가장 긴 두 대각선 방향의 합이 모두 같게 만든 것이다.
예를 들어, 아래 그림은 $3 \times 3$ 크기의 마방진의 예시를 보여준다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2025/f-5-8f6cb91f-caa6-4148-847d-55c291c28081.png"
    width={240}
  />
</div>


$N \times N$개의 수들이 주어질 때,
이 수들을 한 번씩 사용하여 만들 수 있는
$N \times N$ 크기의 서로 다른 마방진은 모두 몇 개인지 구하는
프로그램을 작성하시오.

$N = 3$이고 $N \times N = 9$개의 수가
$9, 8, 7, 6, 5, 4, 3, 2, 1$로 주어진 예를 생각해보자.
아래와 같이 총 $4 \times 2 = 8$가지 마방진을 만들 수 있음을 알 수 있다.

* 이 문제에서 처음 주어진 마방진은
주어진 입력으로 만들 수 있는 마방진 중 하나이다.
* 처음 주어진 마방진을 시계 방향으로 $90$도 회전하면
다음과 같이 또다른 마방진을 만들 수 있다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2025/f-5-ef6528bf-293e-492d-ae9b-b38009d0f28c.png"
    width={390}
  />
</div>

* 시계 방향으로 $180$도, $270$도 회전해도 또다른 마방진을 만들 수 있다.
* 마지막으로, 위에서 만든 마방진을 좌우로 뒤집어도 새로운 마방진을 만들 수 있다.
예를 들어 아래의 마방진은 처음 마방진을 좌우로 뒤집은 것이다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2025/f-5-5a8b2a8e-b839-4418-a326-b9d97c965fff.png"
    width={390}
  />
</div>
## 입력 형식

첫 줄에 마방진의 크기를 나타내는 정수 $N$이 주어진다.
$(2 \le N \le 4)$

그다음 줄에 마방진에 사용할 $N \times N$개의 정수가
공백으로 구분되어 주어진다.
이 수들은 모두 $0$ 이상 $100$ 이하이다.

## 출력 형식

첫 줄에 만들 수 있는 서로 다른 마방진의 수를 출력한다.


## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
3
9 8 7 6 5 4 3 2 1
  </Input>
  {/* prettier-ignore */}
  <Output>
8
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
2
1 0 1 0
  </Input>
  {/* prettier-ignore */}
  <Output>
0
  </Output>
</Examples>

## 예제 3

<Examples>
  {/* prettier-ignore */}
  <Input>
4
1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4
  </Input>
  {/* prettier-ignore */}
  <Output>
256
  </Output>
</Examples>

## 예제 4

<Examples>
  {/* prettier-ignore */}
  <Input>
3
0 0 0 0 0 0 0 0 0
  </Input>
  {/* prettier-ignore */}
  <Output>
1
  </Output>
</Examples>

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={3}>
  $N = 2$
</Subtask>
<Subtask index={2} score={16}>
  $N = 3$
</Subtask>
<Subtask index={3} score={54}>
  $N = 4$
</Subtask>
<Subtask index={4} score={18}>
  주어진 $N \times N$개의 수는 각각 $0$ 또는 $1$이다.
</Subtask>
<Subtask index={5} score={9}>
  모든 입력 케이스가 주어진다.
</Subtask>

## 해설

<Solution>
$N \leq 3$일 때는 $O(N^{2}!)$의 완전 탐색으로도 제한 시간 내에 해결할 수 있습니다. 그러나 $N = 4$인 경우에는 $N^2!$이 너무 커 비효율적이므로, 탐색 범위를 줄이는 아이디어가 필요합니다.

16개의 칸 중 **(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,1), (2,2)** 의 8개 칸만 값을 정하면, 나머지 8칸의 값은 자동으로 결정됩니다.  따라서 실제로 탐색해야 할 경우의 수는 $\frac{16!}{8!} \approx 5.19 \times 10^8$ 정도로 줄어들며, 여기에 적절한 가지치기와 최적화를 적용하면 제한 시간 내에 문제를 해결할 수 있습니다.
</Solution>
