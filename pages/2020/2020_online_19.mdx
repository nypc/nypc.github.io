import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "덕분에 챌린지",
  year: 2020,
  stage: "예선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

\[덕분에 챌린지\]는 의료진들의 헌신에 감사를 표시하기 위해 중앙재난안전대책본부에서 시작한 캠페인이며, 유명인을 포함한 많은 사람들이 동참하고 있다. 챌린지에는 누구나 참여할 수 있으며, 존경을 뜻하는 수어를 사진으로 찍은 뒤 SNS에 올리고, 이어서 참여시킬 사람을 지목하면 된다.

<Figure
  src="/2020/dchallenge1.png"
  caption="&lt;그림 1&gt; [덕분에 챌린지]의 상징"
  width={540}
/>

\[덕분에 챌린지\]에 참여하고 싶어하는 $N+M$ 명의 사람이 있다. 이들 중 한 명이 챌린지를 시작하여 다음으로 참여할 사람을 **두 명 이하**로 지목하고, 지목받은 사람이 챌린지를 이어 나가는 방식으로 챌린지에 참여하려고 한다. 이때, 이미 챌린지를 완료했거나 다른 사람에 의해 지목된 사람은 지목하지 않는 것으로 하자. 즉, 한 사람은 한 번만 지목될 수 있다. 또한, 챌린지를 처음 시작할 한 명을 제외한 사람이 챌린지에 참여하기 위해서는 반드시 다른 사람에 의해 지목되어야 한다.

각 사람이 챌린지를 시작하여 완료하기까지 걸리는 시간이 정해져 있다. 다음으로 참여할 사람을 지목하는 것은 챌린지를 완료한 순간 이루어지며, 지목받은 사람은 그 순간 챌린지를 시작하게 된다. $N+M$ 명의 사람 중 $N$ 명은 챌린지를 하는 데 $X$의 시간이 필요하고, 나머지 $M$ 명은 $Y$의 시간이 필요하다.
모든 사람이 챌린지를 완료하기 위해 필요한 시간의 최솟값을 구하여라.

## 입력 형식

첫 줄에 네 개의 정수 $N$, $M$, $X$, $Y$가 공백으로 구분되어 주어진다.
$(0 \le N, M \le 500;$ $1 \le X, Y \le 1\,000\,000;$ $N+M \ge 1)$

## 출력 형식

첫 줄에 모든 사람이 챌린지를 완료하기 위해 필요한 시간의 최솟값을 출력한다.

## 예제

<Examples>
  {/* prettier-ignore */}
  <Input>
4 1 2 5
  </Input>
  {/* prettier-ignore */}
  <Output>
7
  </Output>
</Examples>

## 예제 설명

다섯 명의 사람 $A$, $B$, $C$, $D$, $E$가 있는데, 사람 $A$, $B$, $C$, $D$는 챌린지를 하는 데 시간 $2$가 필요하고, 사람 $E$는 시간 $5$가 필요한 상황이다.
다음과 같은 과정을 통해 모든 사람이 챌린지를 완료할 수 있고, 이때 필요한 시간은 $7$이며, 이보다 더 빠르게 챌린지를 완료할 수 없다.

1. 시간 $0$에 $A$가 챌린지를 시작한다.
2. 시간 $2$에 $A$가 챌린지를 완료하고, $B$와 $E$를 지목한다.
3. 시간 $4$에 $B$가 챌린지를 완료하고, $C$와 $D$를 지목한다.
4. 시간 $6$에 $C$와 $D$가 챌린지를 완료한다.
5. 시간 $7$에 $E$가 챌린지를 완료한다.

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞추어야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={11}>
  $N, M \le 3$
</Subtask>
<Subtask index={2} score={38}>
  $N, M \le 100$
</Subtask>
<Subtask index={3} score={51}>
  추가적인 제한 조건이 없음.
</Subtask>

## 해설

<Solution>

일반성을 잃지 않고 $X \le Y$라 하자. 다음과 같은 DP 배열을 정의할 수 있다.

$$
\begin{align*}
D[i][j] =\ & \textrm{시간 }X\textrm{가 걸리는 사람 }i\textrm{명,}\\
& \textrm{시간 }Y\textrm{가 걸리는 사람 }j\textrm{명이 챌린지를 마치는데 걸리는 최소 시간}
\end{align*}
$$

초기값은 $D[0][0]=0$이고, 정답은 $D[N][m]$이 된다. $D$ 배열의 점화식은 다음과 같다:

$$
\begin{align*}
D[0][j] &= D[0][j/2] + Y \\
D[i][j] &= \min \left\{ X + \max \left\{ D[k][l], D[i-k-1][j-l] \right\} \right\}
\end{align*}
$$

이 DP를 naive하게 구현하면 시간 복잡도 $\mathcal{O}(N^2M^2)$이 되며 $49$점을 받을 수 있다.

$k$를 고정하면, $D[k]$ 배열과 $D[i-k-1]$ 배열 모두 감소하지 않는 배열임을 알 수 있다. 이 점을 이용하여 two pointers algorithm을 통해 $\mathcal{O}(M)$ 시간에 특정 $k$에 대해 $D[i]$ 배열에 최소 갱신을 해줄 수 있다. 이렇게 DP를 구현하면 시간 복잡도 $\mathcal{O}(N^2M)$에 해결할 수 있다.

</Solution>
