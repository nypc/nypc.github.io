import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "편지",
  year: 2023,
  stage: "Round 2-A",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

$N$ 개의 정점으로 이루어진 트리가 있다.
트리의 정점들은 $1$번부터 $N$번까지 번호가 붙어 있다.
트리의 루트는 $1$번 정점이고, $i$번 정점의 부모는 $P_{i}$번 정점이다.
초기에 $i$번 정점에 $A_{i}$ 개의 편지를 가지고 있다.

매초마다, 하나 이상의 편지를 가지고 있는 모든 루트가 아닌 정점은
자신이 가진 편지 중 하나를 부모 정점으로 보낸다.
또한, 루트 정점은 하나 이상의 편지를 가지고 있을 경우 그 중 하나를 버린다.
어떤 정점이 편지를 부모 정점으로 보내는 것은 부모에 편지가 몇 개 있는지와는 무관하다.
모든 정점은 동시에 편지를 보내기 때문에,
자식 정점으로부터 전달받은 편지가 곧바로 부모 정점으로 전달되지는 않는다.

트리에 편지가 하나도 존재하지 않을 때까지 몇 초가 필요할 지 계산하려고 한다.
단, 처음부터 트리에 편지가 하나도 존재하지 않는 경우는 $0$ 초가 필요한 것으로 생각하자.

또한, 업데이트가 $Q$ 개 주어진다.
$i$ 번째 업데이트는 $X_{i}$번 정점에 있는 편지의 개수를 $Y_{i}$ 개로 바꾼다.

여러분의 프로그램은 초기 트리에서 모든 편지가 버려지는 데 몇 초가 필요한지
계산하여야 하며,
각 업데이트 이후의 트리에서 모든 편지가 버려지는 데
몇 초가 필요한지 계산해야 한다.
각 업데이트는 이전 업데이트들이 모두 적용된 트리에
**누적하여 적용되는 것**임에 유의하라.

편지들을 보내거나 버리는 과정은 실제로
트리에 적용되지 않음에 주의하라.
즉, 모든 편지가 버려지는 데 몇 초가 필요한지는
계산만 하는 것이며 트리의 편지 위치들을 바꾸지는 않는다.


## 입력 형식

첫 줄에 정점의 수 $N$과 업데이트의 수 $Q$가 공백으로 구분되어 주어진다.
($2 \le N \le 200\,000;$ $0 \le Q \le 200\,000$)

그다음 줄에 $N - 1$ 개의 정수 $P_{2}, \cdots, P_{N}$이 공백으로 구분되어 주어진다.
($1 \le P_{i} < i$)

그다음 줄에 $N$ 개의 정수 $A_{1}, \cdots, A_{N}$이 공백으로 구분되어 주어진다.
($0 \le A_{i} \le 1\,000\,000\,000$)

이어지는 $Q$ 개의 줄의 $i$ 번째 줄에는
두 정수 $X_{i}$와 $Y_{i}$가 공백으로 구분되어 주어진다.
($1 \le X_{i} \le N;$ $0 \le Y_{i} \le 1\,000\,000\,000$)

## 출력 형식

첫 줄에 초기 트리에 대한 답을 출력한다.

이어지는 $Q$ 개의 줄의 $i$ 번째 줄에
$i$ 번째까지 업데이트가 적용된 이후의 트리에 대한 답을 출력한다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
5 1
1 1 1 1
0 0 1 2 0
2 2
  </Input>
  {/* prettier-ignore */}
  <Output>
4
6
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
6 5
1 2 3 4 5
0 0 0 0 0 0
4 2
6 1
3 2
1 2
1 3
  </Input>
  {/* prettier-ignore */}
  <Output>
0
5
6
7
7
8
  </Output>
</Examples>

## 예제 설명

예제 1에서, 초기 트리의 모양과 각 정점에 있는 편지의 개수는 아래 그림과 같다. 그림의 사각형이
정점이며, 사각형 안의 점들이 편지들이다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-1.0aa952db2b993734.png"
    width={400}
  />
</div>

$1$ 초가 지나면 편지들은 아래와 같이 이동한다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-2.022dacc83d6c9d3d.png"
    width={400}
  />
</div>

$1$ 초가 더 지나면 루트 정점에서 한 개의 편지가 버려지면서 아래와 같은 상황이 된다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-3.be18c60d088402e8.png"
    width={400}
  />
</div>

$1$ 초가 더 지나면 루트 정점에 한 개의 편지가 남은 상황이 된다.
따라서, 초기 트리에서
모든 편지가 버려지는데 $4$ 초가 걸린다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-4.63eec58e8ecb8ca1.png"
    width={400}
  />
</div>

유일한 업데이트가 초기 트리에 적용되고 나면 아래와 같은 상황이 된다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-5.3da1f36ae1ccf7f5.png"
    width={400}
  />
</div>

$1$ 초가 지나면 아래와 같은 상황이 된다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-6.0d91d2e715b72917.png"
    width={400}
  />
</div>

$1$ 초가 더 지나면 루트 정점에만 네 개의 편지가 있는 상황이 된다.
따라서 이 경우에는 $6$ 초가 지난 후 모든 편지가 버려진다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/11-7.051da021a417f2e6.png"
    width={400}
  />
</div>

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며,
한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={7}>
  $N \le 2\,000;$ $Q \le 5;$ $A_i \le 5;$ $Y_j \le 5$
</Subtask>
<Subtask index={2} score={13}>
  $N \le 2\,000;$ $Q \le 2\,000;$ $P_{i} = i - 1$
</Subtask>
<Subtask index={3} score={14}>
  $N \le 2\,000;$ $Q \le 5$
</Subtask>
<Subtask index={4} score={15}>
  $N \le 2\,000;$ $Q \le 2\,000$
</Subtask>
<Subtask index={5} score={16}>
  $P_{i} = i - 1$
</Subtask>
<Subtask index={6} score={17}>
  $Q \le 5$
</Subtask>
<Subtask index={7} score={18}>
  추가적인 제한 조건이 없음.
</Subtask>

## 해설

<Solution>
먼저 트리가 선형인 경우인 종류 3과 6을 살펴보자. 각 편지에 대해 (현재 자신이 위치한 노드의 깊이) + (자신보다 깊은 노드에 위치한 편지의 수)를 계산하자.
모든 편지들에 대해 이 값을 계산하면, 이들 중 최댓값에 1을 더한 값이 하나의 쿼리에 대한 답이 된다.

편지의 개수가 업데이트될 때 이 값은 세그먼트 트리를 이용해 관리할 수 있으므로, 각 쿼리를 $\mathcal{O}(\lg N)$의 시간복잡도로 해결할 수 있다.
트리에 편지가 하나도 없는 경우나, 가장 깊은 노드에 편지가 없는 경우 등에 주의해야 한다.

전체 문제의 경우, 깊이가 같은 노드들을 하나로 합쳐도 답이 변하지 않는다는 사실을 이용해 트리를 선형으로 바꾸어 같은 방법으로 해결할 수 있다.
</Solution>
