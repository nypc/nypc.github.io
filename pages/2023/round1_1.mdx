import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "메이플스토리 새로운 직업 고르기",
  year: 2023,
  stage: "Round 1",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

메이플스토리에는 여러 가지 모험가 직업들이 있다.

<div style={{ display: "flex" }}>
  <Figure
    src="/2023/1-1.6a31bfc92fee281a.png"
    width={1000}
  />
</div>

메이플스토리의 팬인 당신은 여러 모험가 캐릭터를 키워봤다.
이제 안 해본 모험가 캐릭터를 키워보려고 한다. 메이플스토리에 존재하는 모든 모험가 직업과,
당신이 키워본 모험가 직업이 주어졌을 때 당신이 **새로** 키워볼 수 있는 모험가 직업을
**모두** 나열하는 프로그램을 작성하시오.

## 입력 형식

첫 줄에 메이플스토리에 존재하는 모든 모험가 직업의 수 $N$이 주어진다. ($1 \le N \le 150$)

이어지는 $N$ 개의 줄에는 모험가 직업이 주어진다.
모험가 직업은 영어 알파벳만으로 이루어진 길이 $1$ 이상
$15$ 이하인 문자열이다.
같은 모험가 직업이 두 번 이상 나오는 경우는 **없다**.
대문자와 소문자는 **구별된다**. 예를 들면, `hero`와 `Hero`는 다른 직업이다.

그다음 줄에 당신이 키워본 모험가 직업의 수 $K$가 주어진다. ($1 \le K \le 150$)

이어지는 $K$ 개의 줄에는 당신이 키워본 모험가 직업이 주어진다.
당신이 키워본 모험가 직업은 메이플스토리에 존재하는
모든 모험가 직업 중 한 가지이며,
다른 캐릭터로 같은 모험가 직업을 택할 수 있으므로
**같은 모험가 직업이 두 번 이상 나올 수 있다**.

## 출력 형식

첫 줄에 당신이 새로 키워볼 수 있는 모험가 직업의 수 $T$를 출력한다.

이어지는 $T$ 개의 줄에 새로 키울 수 있는 모험가 직업을 출력한다.
출력 순서는 중요하지 않다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
2
Hero
Paladin
1
Hero
  </Input>
  {/* prettier-ignore */}
  <Output>
1
Paladin
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
2
Hero
Paladin
2
Paladin
Hero
  </Input>
  {/* prettier-ignore */}
  <Output>
0
  </Output>
</Examples>

## 예제 3

<Examples>
  {/* prettier-ignore */}
  <Input>
3
Hero
Paladin
DarkKnight
3
Hero
Hero
Hero
  </Input>
  {/* prettier-ignore */}
  <Output>
2
DarkKnight
Paladin
  </Output>
</Examples>

## 예제 설명

예제 1에서, $2$ 가지 직업 `Hero`와 `Paladin`이 존재하고 당신은 `Hero`만 키워봤다.
따라서 당신이 새로 키워볼 수 있는 직업은 `Paladin` 하나다.

예제 2에서, $2$ 가지 직업 `Hero`와 `Paladin`이 존재하고 당신은 `Hero`와 `Paladin`을 모두 키워봤다.
따라서 당신이 새로 키워볼 수 있는 직업은 없다.

예제 3에서, $3$ 가지 직업 `Hero`, `Paladin`, `DarkKnight`가 존재하고 당신은 `Hero`만 세 번 키워봤다.
따라서 당신이 새로 키워볼 수 있는 직업은 `DarkKnight`와 `Paladin` 둘이다.
이 둘의 순서가 바뀌어도 정답임에 유의하라.

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={34}>
  $N = 2;$ $K = 1$
</Subtask>
<Subtask index={2} score={35}>
  모든 문자열은 길이가 $1$이다.
</Subtask>
<Subtask index={3} score={31}>
  추가적인 제한 조건이 없음.
</Subtask>

## 해설

<Solution>
주어진 $N$ 개의 문자열을 담고 있는 배열에서, $K$ 개의 문자열을 찾아 제거하는 작업을 구현하면 충분하다.
혹은, 각 $N$ 개의 문자열이 $K$ 개의 문자열 중 하나인지를 판별하는 함수를 작성하여 구현할 수도 있다.
</Solution>
