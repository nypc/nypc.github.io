import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "비트문자열",
  year: 2022,
  stage: "Round 2-B",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

어떤 양의 정수 $K$에 대해 길이가 $2^K$인 비트문자열 $X$가 있다.
$X$의 비트들은 왼쪽부터 순서대로 $1$번부터 $2^K$번까지 번호가 붙어 있다.
처음에 $X$의 모든 비트는 $0$이다.

다음과 같은 함수 $f(x)$가 있다. 이때, $x$는 길이가 $2^k$ 꼴인 비트문자열이다.

1. $x$의 길이가 $1$인 경우, 아무 작업 없이 종료한다.
2. $x$를 절반으로 나눈다. 왼쪽 절반을 $l$, 오른쪽 절반을 $r$이라고 하자.
3. 왼쪽 절반 $l$의 비트를 뒤집는다.
4. $f(l)$을 재귀호출 한다.
5. $f(r)$을 재귀호출 한다.

여기서, 비트를 뒤집는다는 것은 $0$은 $1$로 만들고, $1$은 $0$으로 만든다는 것을 의미한다.

모든 비트가 $0$인 길이가 $2^K$인 비트문자열 $X$에서 $f(X)$를 호출한 이후
비트문자열 $X$를 $S_K$라고 하자.

$K = 1$인 경우, 초기 비트문자열은 $00$이다.
위 작업의 결과로 최종 비트문자열은 $10$이 된다. 
(왼쪽 절반인 $0$이 $1$로 바뀌었다.)

$K = 2$인 경우, 초기 비트문자열은 $0000$이다.
위 작업에서 첫 번째 호출이 비트문자열을 $1100$으로 바꾼다. 
첫 번째 호출에서 4번 과정의 재귀호출을 하면
비트문자열이 $0100$으로 바뀌고,
5번 과정의 재귀호출을 하면 비트문자열은 $0110$으로
바뀌므로, 최종 비트문자열은 $0110$이 된다.

$K = 3$인 경우, 이와 마찬가지로 최종 비트문자열은 $10010110$이 된다.

정리하면 다음과 같다.

| $K$ | $S_K$              |
|-----|--------------------|
| $1$ | $10$               |
| $2$ | $0110$             |
| $3$ | $10010110$         |
| $4$ | $0110100110010110$ |

양의 정수 $K$, $L$, $R$를 입력으로 받아,
$S_K$의 $L$번 비트부터 $R$번 비트까지 $1$의 개수를 구하는 프로그램을 작성하시오.

## 입력 형식

첫 줄에 테스트 케이스의 수를 나타내는
정수 $T$가 주어진다. ($1 \le T \le 200\,000$)

각 테스트 케이스의 첫 줄에 양의 정수 $K$,
$L$, $R$이
공백으로 구분되어 주어진다.
($1 \le K, L, R \le 1\,000\,000\,000\,000\,000\,000;$ $L \le R \le 2^{K}$)

## 출력 형식

각 테스트 케이스에 대해, $S_K$의 $L$번 비트부터 $R$번 비트까지 $1$의 개수를 각 줄에 출력한다.

## 예제

<Examples>
  {/* prettier-ignore */}
  <Input>
3
2 2 4
3 1 6
4 3 6
  </Input>
  {/* prettier-ignore */}
  <Output>
2
3
2
  </Output>
</Examples>

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={11}>
  $T \le 49;$ $K \le 3$
</Subtask>
<Subtask index={2} score={12}>
  $T \le 10;$ $K \le 20$
</Subtask>
<Subtask index={3} score={24}>
  $K \le 20$
</Subtask>
<Subtask index={4} score={16}>
  $K \le 60;$ $L = R$
</Subtask>
<Subtask index={5} score={18}>
  $K \le 60$
</Subtask>
<Subtask index={6} score={19}>
  추가적인 제한 조건이 없음.
</Subtask>

<Solution>
하나의 입력에 $20$만 개의 테스트케이스가 있을 수 있으므로, 각 테스트케이스에 대한 답을 빠르게 구해야 한다.

$S_i$에 여러 특징이 있는데 그중 하나로 $2k$번째 문자와 $2k-1$번째 문자가 서로 다르다는 점이다. 
이 점을 이용하면 구간 $[L, R]$에서 $L$번째 문자와 $R$번째 문자를 알면 $0$과 $1$의 개수를 셀 수 있다.

$S_i$의 $x$번째 문자를 구하는 방법은 다음과 같다:
$x > 2^{i-1}$이라면, $S_{i-1}$의 $x-2^{i-1}$번째 문자를 구하면 된다.
그렇지 않다면, $S_{i-1}$의 $x$번째 문자를 구하고 뒤집으면 된다.
만약 $i$가 엄청 나게 크다면 $S_{60}$의 $x$번째 문자를 구하고 $i$의 홀짝성에 따라 그것을 뒤집으면 된다.
각 테스트케이스 마다 시간복잡도는 $O(min(60, lg K))$가 된다.
</Solution>
