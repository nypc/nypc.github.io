import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "멘토링 시스템",
  year: 2022,
  stage: "Round 2-B",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

넥슨의 한 게임에는 신규 유저의 게임 적응을 돕기 위한 멘토링 시스템이 있다.

이 멘토링 시스템에는 게임을 오래 플레이한 멘토가 $N$ 명 등록되어있고,
새로 게임에 가입한 멘티 $N$ 명이 등록되어 있어, 이들을 1:1 매칭시킨다.
편의상, 각 멘토는 $1$부터 $N$까지 번호가 매겨져 있고,
각 멘티 또한 $1$부터 $N$까지 번호가 매겨져 있다.

어떤 멘토와 어떤 멘티를 아무 이유 없이 매칭시켜주면
멘토링 시스템의 질이 떨어질 수 있기 때문에,
유저들의 접속 시간대, 플레이 스타일, 직업군 등
다양한 요소를 고려하여 멘토링이 가능한 멘토와 멘티 쌍이 결정되었다.

예를 들어, $N = 3$인 상황을 보자.

* 멘토 $1$이 멘티 $3$과 멘토링이 가능하고,
* 멘토 $2$가 멘티 $1$과 멘토링이 가능하고,
* 멘토 $2$가 멘티 $2$와 멘토링이 가능하고,
* 멘토 $3$이 멘티 $1$과 멘토링이 가능하고,
* 멘토 $3$이 멘티 $2$와 멘토링이 가능하다고 하자.

멘토 $1$을 멘티 $3$과, 멘토 $2$를 멘티 $1$과, 멘토 $3$을 멘티 $2$와 매칭해줄 수 있다.

다른 방법 또한 가능한데, 멘토 $1$을 멘티 $3$과, 멘토 $2$를 멘티 $2$와,
멘토 $3$을 멘티 $1$과 매칭해줄 수도 있다.
즉, 1:1 매칭은 가능하지만 그 방법이 유일하지 않다.

$N = 3$인 다른 상황을 보자.

* 멘토 $1$이 멘티 $2$와 멘토링이 가능하고,
* 멘토 $2$가 멘티 $1$과 멘토링이 가능하고,
* 멘토 $2$가 멘티 $2$와 멘토링이 가능하고,
* 멘토 $2$가 멘티 $3$과 멘토링이 가능하고,
* 멘토 $3$이 멘티 $2$와 멘토링이 가능하다고 하자.

이 경우, 멘토 $1$은 멘티 $2$와만 멘토링이 가능하고, 멘토 $3$ 또한 멘티 $2$와만 멘토링이 가능하다.
즉, 1:1 매칭이 불가능하다.

마지막으로, $N = 3$인 다른 상황을 보자.

* 멘토 $1$이 멘티 $2$와 멘토링이 가능하고,
* 멘토 $2$가 멘티 $2$와 멘토링이 가능하고,
* 멘토 $2$가 멘티 $3$과 멘토링이 가능하고,
* 멘토 $3$이 멘티 $1$과 멘토링이 가능하고,
* 멘토 $3$이 멘티 $3$과 멘토링이 가능하다고 하자.
 
멘토 $1$은 멘티 $2$와, 멘토 $2$는 멘티 $3$과, 멘토 $3$은 멘티 $1$과 매칭해줄 수 있다.
다른 방법으로는 매칭이 불가능하다.
즉, 1:1 매칭이 가능하며 그 방법이 유일하다.

멘토와 멘티의 수 $N$과 멘토링이 가능한 멘토와 멘티 쌍이 주어졌을 때,
이들을 1:1 매칭시키는 것이 가능하며,
그 방법이 유일한지 구하는 프로그램을 작성하시오.

## 입력 형식

첫 줄에 멘토와 멘티의 수를 나타내는 정수 $N$과
멘토링이 가능한 멘토와 멘티 쌍의 수를 나타내는 정수 $M$이
공백으로 구분되어 주어진다.
($1 \le N \le M \le 1\,000\,000$)

이어지는 $M$ 개의 줄에 멘토의 번호를 나타내는 정수 $i$와
멘티의 번호를 나타내는 정수 $j$가 공백으로 구분되어 주어진다.
($1 \le i, j \le N$)

이는 멘토 $i$와 멘티 $j$가 멘토링이 가능하다는 것을 의미한다.
같은 $(i, j)$ 쌍이 여러 번 주어지지 않는다.

## 출력 형식

첫 줄에
$N$ 명의 멘토와 $N$ 명의 멘티를 1:1 매칭시키는 것이 가능하며, 그 방법이 유일하다면
`YES`를 출력하고, 그렇지 않다면 `NO`를 출력한다.

만약 답이 `YES`라면, 이어지는 $N$ 줄의 $i$ 번째 줄에 멘토 $i$와 매칭될 멘티의 번호 $j$를 출력한다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
3 5
1 2
2 2
2 3
3 1
3 3
  </Input>
  {/* prettier-ignore */}
  <Output>
YES
2
3
1
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
3 5
1 3
2 1
2 2
3 1
3 2
  </Input>
  {/* prettier-ignore */}
  <Output>
NO
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
3 5
1 2
2 1
2 2
2 3
3 2
  </Input>
  {/* prettier-ignore */}
  <Output>
NO
  </Output>
</Examples>

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며,
한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={19}>
  $N \le 10$
</Subtask>
<Subtask index={2} score={24}>
  $N \le 20$
</Subtask>
<Subtask index={3} score={28}>
  $N \le 300$
</Subtask>
<Subtask index={4} score={29}>
  추가적인 제한 조건이 없음.
</Subtask>

## 해설

<Solution>
어떤 멘토가 가르칠 수 있는 멘티가 하나뿐이라면, 해당 멘티는 해당 멘토랑 이어져야 합니다. 
마찬가지로, 어떤 멘티를 가르칠 수 있는 멘토가 하나뿐이라면, 해당 멘토는 해당 멘티랑 이어져야 합니다. 
이 과정을 여러 번 반복해서, 남은 멘토와 멘티가 없다면 이렇게 구한 방법이 유일한 해답이고, 이를 출력하면 됩니다. 
만약에 남은 멘토와 멘티가 있다면 두 가지 경우의 수가 있습니다. 

1. 어떤 멘토가 가르칠 수 있는 멘티가 하나도 남지 않았거나, 어떤 멘티를 가르칠 수 있는 멘토가 하나도 남지 않은 경우. 
이 경우에는 해답이 없으므로, `NO`를 출력하면 됩니다. 

2. 모든 멘토가 가르칠 수 있는 멘티가 $2$명 이상이고, 모든 멘티를 가르칠 수 있는 멘토가 $2$명 이상인 경우. 
이 경우에는 또 다시 두 가지 경우가 존재합니다. 

2-1. 답이 하나라도 존재하는 경우. 답 중 하나에서 $i$번 멘토와 이어진 멘티를 $A_i$, $j$번 멘티와 이어진 멘토를 $B_j$라고 해 봅시다. 모든 멘토가 가르칠 수 있는 멘티가 $2$명 이상이므로, $1$번 멘토와 이어진 다른 멘티 $x$가 존재합니다. 
$1$번 멘토가 $A_1$번 멘티 대신 $x$번 멘티와 이어지고, $B_x$번 멘토는 $x$번 멘티 대신 다른 멘티 $y$와 이어지고, $B_y$번 멘토는 $y$번 멘티 대신 또 다른 멘티 $z$와 이어지고,... 이를 반복하다 보면 어느 순간 $1$번 멘토로 돌아오게 됩니다. 이는 처음의 답과는 다른 답이고, 따라서 답이 존재한다면 유일하지 않으므로 `NO`가 답이 됩니다. 

2-2. 답이 존재하지 않는 경우. 이 경우에는 해답이 없으므로, `NO`가 답이 됩니다. 따라서 어느 경우에도 답이 존재하거나 유일한 지 확인하지 않고 `NO`를 출력하는 것이 정답입니다. 자료구조를 이용해 차수가 1인 정점들을 보면서 하나씩 이어주면, $O(N+M)$에 문제를 해결할 수 있습니다.
</Solution>