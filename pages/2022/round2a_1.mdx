import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  bikoId: 111,
  title: "사진작가",
  year: 2022,
  stage: "Round 2-A",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

$N$ 개의 구조물이 좌우로 배치되어 있다.
왼쪽에서 $i$ 번째 구조물의 색은 $A_i$이다.

사진작가 배찌는 좌우로 연속한 구조물을 사진에 담으려고 한다.
다만, 배찌는 개성 있는 사진을 찍고 싶기 때문에
사진에 색이 같은 구조물이 여러 개 있으면 마음에 들어 하지 않고,
최대한 많은 구조물을 사진에 담고 싶어 한다.

배찌를 도와 구조물의 색 정보가 주어졌을 때,
한 사진에 담을 수 있는 구조물 수의 최댓값을 구하는
프로그램을 작성하시오.

## 입력 형식

첫 줄에 구조물의 수를 나타내는 정수 $N$이 주어진다.
($1 \le N \le 200\,000$)

두 번째 줄에 $N$ 개의 정수
$A_{1}$, $A_{2}$, $\cdots$, $A_{N}$이 공백으로 구분되어 주어진다.
($1 \le A_{i} \le 1\,000\,000$)

## 출력 형식

첫 줄에 한 사진에 담을 수 있는 구조물 수의 최댓값을 출력한다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
7
3 1 4 1 5 9 2
  </Input>
  {/* prettier-ignore */}
  <Output>
5
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
7
1 1 1 1 1 1 1
  </Input>
  {/* prettier-ignore */}
  <Output>
1
  </Output>
</Examples>

## 예제 설명

예제 1에서, 왼쪽에서 $3$ 번째 구조물부터 $7$ 번째 구조물까지
한 사진에 담을 수 있으며,
이보다 더 많은 구조물을 한 사진에 담을 수 없다.

예제 2에서, 모든 구조물의 색이 같기 때문에
한 사진에 최대 한 개의 구조물만 담을 수 있다.

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={7}>
  $N \le 3$
</Subtask>
<Subtask index={2} score={21}>
  $N \le 100$; $A_{i} \le 1\,000$
</Subtask>
<Subtask index={3} score={13}>
  $A_{i} \le 20$
</Subtask>
<Subtask index={4} score={25}>
  $N \le 5\,000$
</Subtask>
<Subtask index={5} score={34}>
  추가적인 제한 조건이 없음.
</Subtask>

## 해설

<Solution>
수열에서 각 수가 들어온 횟수를 배열에 저장합니다. 수열이 조건을 만족하기 위해서는 각 수가 한번 이하로 등장해야 
하므로, 배열에 저장된 값이 $1$을 넘으면 안 됩니다. 이러한 방식으로 부분수열의 왼쪽 끝점을 고정했을 때, 가능한 
오른쪽 끝점의 최댓값을 구할 수 있습니다.

한편 왼쪽 끝점이 점점 증가할 때 가능한 오른쪽 끝점의 최댓값 또한 점점
증가한다는 것을 알 수 있습니다. 이 성질을 활용하면 $\mathcal{O}(N)$에 문제를 해결할 수 있습니다. 이러한 테크닉을 
two pointer 또는 sliding window라 합니다.
</Solution>