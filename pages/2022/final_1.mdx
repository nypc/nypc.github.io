import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Simulators,
  Solution,
  Subtask,
} from "components";

export const meta = {
  title: "조약돌 순서",
  year: 2022,
  stage: "본선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

해변의 조용한 마을에 사는 수희는 바닷가에서 주운 각종 조약돌을 가지고 놀곤 한다.
오늘도 수희는 $K$ 개의 조약돌을 주워 모래사장에 일렬로 줄을 세웠다.
형형색색의 조약돌이 예쁘게 한 줄로 나열된 것을 보고, 
수희는 인접한 조약돌 두 개의 위치를 맞바꾸기를 $N$ 번 한 후, 조약돌의 순서가 
어떻게 바뀌는지 궁금해졌다.

수희가 조약돌의 위치를 맞바꾸는 규칙은 단순하다. 
첫 번째 조약돌부터 시작하여 오른쪽으로 이동하면서 
인접한 두 개의 조약돌, 즉, $i(1 \le i < K)$ 번째 조약돌과 $(i+1)$ 번째 조약돌의 
위치를 서로 맞바꾸어 가다가 마지막 조약돌의 위치가 바뀌게 되면
다시 처음으로 돌아와 위치 바꾸기를 계속하되 이런 위치 바꾸기 횟수를 $N$ 번 한 후 
조약돌이 어떤 순서로 나열되어 있는지를 알고자 한다.

예를 들어, $5$ 개의 조약돌이 있고, 수희는 위치 바꾸기를 $7$ 번 하고자 한다.
편의상 각 조약돌을 $1$부터 시작된 수로 표현할 때, 
처음 일렬로 줄 선 조약돌의 순서는 $($ $1$ $2$ $3$ $4$ $5$ $)$ 라고 하자. 
첫 번째 조약돌부터 시작하여 인접한 조약돌의 위치를 
맞바꿀 때마다 조약돌의 순서가 어떻게 바뀌는지는 다음과 같다.

| 단계 | 상태 | 설명 |
| --- | --- | --- |
| $1$ | $($ $\color{red}2$ $\color{red}1$ $3$ $4$ $5$ $)$ | 첫 번째와 두 번째의 위치가 맞바뀜 |
| $2$ | $($ $2$ $\color{red}3$ $\color{red}1$ $4$ $5$ $)$ | 두 번째와 세 번째의 위치가 맞바뀜 |
| $3$ | $($ $2$ $3$ $\color{red}4$ $\color{red}1$ $5$ $)$ | 세 번째와 네 번째의 위치가 맞바뀜 |
| $4$ | $($ $2$ $3$ $4$ $\color{red}5$ $\color{red}1$ $)$ | 마지막 조약돌의 위치가 바뀌었으므로 첫 조약돌부터 다시 시작 |
| $5$ | $($ $\color{red}3$ $\color{red}2$ $4$ $5$ $1$ $)$ | 첫 번째와 두 번째의 위치가 맞바뀜 |
| $6$ | $($ $3$ $\color{red}4$ $\color{red}2$ $5$ $1$ $)$ | 두 번째와 세 번째의 위치가 맞바뀜 |
| $7$ | $($ $3$ $4$ $\color{red}5$ $\color{red}2$ $1$ $)$ | 세 번째와 네 번째의 위치가 맞바뀜 |

$5$ 개의 조약돌 순서는 처음엔 $($ $1$ $2$ $3$ $4$ $5$ $)$ 였으나, 위치 맞바꾸기를 
$7$ 번 한 후 조약돌의 순서는 $($ $3$ $4$ $5$ $2$ $1$ $)$ 로 바뀌었음을 알 수 있다.

처음에 수희에게 주어진 $K$ 개의 조약돌 순서가 $($ $1$ $2$ $3$ $\cdots$ $K$ $)$라고 할 때,
위에서 설명한 방식으로 위치 바꾸기를 $N$ 번 한 후 조약돌 순서가 어떻게
바뀌는지를 찾는 프로그램을 작성하시오.

## 입력 형식

첫 줄에 조약돌의 수를 나타내는 정수 $K$와 위치 바꾸기 횟수를 나타내는 정수 $N$이
공백으로 구분되어 주어진다.
($2 \le K \le 300\,000;$ 
$0 \le N \le 1\,000\,000\,000\,000\,000\,000$)

## 출력 형식

첫 줄에 조약돌의 순서를 나타내는 정수 $K$ 개를 공백으로 구분하여 출력한다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
5 7
  </Input>
  {/* prettier-ignore */}
  <Output>
3 4 5 2 1
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
7 0
  </Input>
  {/* prettier-ignore */}
  <Output>
1 2 3 4 5 6 7
  </Output>
</Examples>


## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞혀야 
그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={43}>
  $N \le 10\,000\,000$
</Subtask>
<Subtask index={2} score={9}>
  $K = 2$
</Subtask>
<Subtask index={3} score={41}>
  $K \le 1\,000$
</Subtask>
<Subtask index={4} score={7}>
  추가적인 제한 조건이 없음.
</Subtask>

## 해설

<Solution>
다음과 같은 관찰을 사용합니다. 

1. $K-1$번 바꾼 이후에는, 가장 왼쪽에 있던 수가 가장 오른쪽으로 이동합니다. 
2. 위의 동작을 $K$번 한 이후에는, 배열은 원래대로 돌아옵니다.
</Solution>