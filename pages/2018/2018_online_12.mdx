import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Solution,
  Subtask,
} from "components";

export const meta = {
  bikoId: 1701,
  title: "강력한 한방, 필살기",
  year: 2018,
  stage: "예선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

가로 $3$칸, 세로 $4$칸의 보드에 말들이 배치되어 있다. 아래 규칙에 따라 이동 혹은 추가를 최대 한 번만 수행해서 가장 높은 점수를 만들어 보자.

1. 말

- 나의 말과 적의 말이 있다.
- 각 말은 공격력과 체력을 가진다.

2. 이동 규칙

- 이동은 나의 말만 할 수 있다.
- 말은 상하좌우, 대각선 방향 중 한 방향으로 한 칸을 움직일 수 있다.
- 말은 빈 칸이나 적의 말이 있는 칸으로 움직일 수 있다.
- 적의 말이 있는 칸으로 움직이는 경우 나의 말의 공격력이 적의 말의 체력보다 높아야 한다. 또, 나의 말의 체력이 적의 말의 공격력보다 높아야 한다.

3. 추가 규칙

- 보드에 아직 올라오지 않은 나의 말들의 리스트가 주어진다.
- 나의 말 중 하나를 빈 칸에 배치할 수 있다.

이동 혹은 추가를 최대 한 번 수행한 후 점수는 보드에서 나의 말로 이루어진 빙고들을 이용하여 계산한다. 빙고는 가로로 $3$칸이 모두 나의 말인 경우, 세로로 $3$칸이 모두 나의 말인 경우, 대각선으로 $3$칸이 모두 나의 말인 경우를 말한다. 즉, 세로로 $4$칸이 모두 나의 말인 경우, 세로 빙고가 $2$개 있다고 본다.

빙고 하나에 대해서 계산되는 점수는 빙고에 속한 나의 말들의 공격력의 합이다. 한 말이 여러 빙고에 속하는 경우, 그 말의 공격력은 해당하는 모든 빙고의 점수 계산에 포함된다. 모든 빙고에 대해 계산한 점수를 합한 것이 최종 점수이다.

## 입력 형식

처음에 보드의 상태가 $4$줄로 주어진다. 한 줄의 세 칸에 대한 정보가 공백 문자를 사이에 두고 주어진다.

칸이 비어 있는 경우 정보는 글자 `X`로 주어진다.

칸에 나의 말이 있는 경우 정보는 `M[공격력값][체력값]`의 형태로 주어진다. (예, `M150/50`, `M50/50` 등)

칸에 적의 말이 있는 경우 정보는 `O[공격력값][체력값]`의 형태로 주어진다. (예, `O50/70`, `O10/20` 등)

다음 줄에 보드에 아직 올라가지 않은 나의 말들의 개수 $N$이 주어진다. ($1 \le N \le 10$)

다음 줄에 $N$개의 나의 말에 대한 정보가 위와 같은 형태로 주어진다. 공격력값과 체력값은 모두 $1$ 이상 $999$ 이하의 정수이다.

## 출력 형식

받을 수 있는 가장 높은 점수를 정수로 출력한다.

## 예제

<Examples>
  {/* prettier-ignore */}
  <Input>
    X O200/50 X
    M150/50 M50/50 X
    X O100/100 M50/50
    X X X
    2
    M100/50 M50/50
  </Input>
  {/* prettier-ignore */}
  <Output>
    300
  </Output>
</Examples>

## 채점 방식

모든 입력 케이스를 맞추어야 전체 점수를 받을 수 있다. 하나의 입력 케이스라도 틀리면 0점이 부여된다.

## 해설

<Solution>
  $4 \times 3$ 크기의 보드에 배치된 말들을 규칙에 따라 이동 혹은 추가했을 때
  가장 많은 점수를 얻는 방법을 찾아야 한다. 규칙이 복잡하기는 하지만 경우의 수가
  매우 작으므로 모든 경우를 체계적으로 따지면 답을 구할 수 있다.
</Solution>
