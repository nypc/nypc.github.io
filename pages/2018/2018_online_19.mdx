import {
  Examples,
  Input,
  Output,
  Figure,
  PostLayout,
  Solution,
  Subtask,
} from "components";

export const meta = {
  bikoId: 1708,
  title: "종이접기",
  year: 2018,
  stage: "예선",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

크기가 $N \times M$ 인 종이를 계속 접어 크기가 $1 \times 1$ 이 될 때까지 접은 후 이를 펼치면 종이엔 줄무늬가 생긴다. 어떤 줄무늬는 위로 볼록하고, 어떤 것은 아래로 볼록한 모양을 띄게 된다. 위로 볼록한 무늬를 굵은 실선으로, 아래로 볼록한 무늬를 굵은 점선으로 나타내자. 아래 그림은 $2 \times 3$ 크기의 종이를 어떤 순서로 접었나에 따른 서로 다른 줄 무늬를 보여주고 있다.

<Figure src="/2018/online_images/paper1.png" alt="" />

격자의 정보를 나타내는 자연수 $N$과 $M$, 그리고 줄무늬를 나타내는 정보가 주어질 때, 그런 무늬가 실제로 종이를 접은 후 펼쳐서 얻어진 그림인지, 아니면 인위적으로 그린 그림인지를 판단하는 프로그램을 작성하시오.

## 입력 형식

첫째 줄에 테스트 케이스의 수 $T$ ($1 \le T \le 10$)가 주어진다.

각 테스트 케이스의 첫째줄엔 종이의 세로 크기를 나타내는 정수 $N$($2 \le N \le 50$)과 가로 크기를 나타내는 정수 $M$($2 \le M \le 50$)이 주어진다.

이어지는 $N$줄 각각엔 $M-1$ 개의 정수($0$ 또는 $1$)가 주어지는데 이는 격자의 세로방향 무늬에 대한 정보이다. 즉, $i$ 번째 줄에 있는 $M-1$개 정수는 격자의 $i$ 번째 행에 있는 $M-1$개의 세로 방향에 관한 무늬 정보이다. $1$은 위로 볼록한 무늬를, $0$은 아래로 볼록한 무늬를 의미한다.

이어지는 $N-1$ 줄 각각엔 $M$ 개의 정수($0$ 또는 $1$)가 주어지는데 이는 가로방향 무늬에 대한 정보이다. 즉, $i$ 번째 줄에 있는 $M$ 개 정수는 격자의 $i$ 번째 행에 있는 $M$ 개의 가로 방향에 관한 무늬 정보이다. (아래 그림 참조)

<Figure src="/2018/online_images/paper2.png" alt="" />

## 출력 형식

한 줄로 결과를 출력한다. 주어진 무늬 정보가 실제로 종이를 접은 후 펼쳐서 얻어지는 것이면 $1$, 그렇지 않으면 $0$을 출력한다.

## 예제 1

<Examples>
  {/* prettier-ignore */}
  <Input>
    2
    2 3
    1 1
    1 1
    0 1 0
    4 6
    1 0 1 1 0
    0 1 0 0 1
    1 0 1 1 0
    0 1 0 0 1
    1 1 1 1 1 1
    1 1 1 1 1 1
    1 1 1 1 1 1
  </Input>
  {/* prettier-ignore */}
  <Output>
    1 1
  </Output>
</Examples>

## 예제 2

<Examples>
  {/* prettier-ignore */}
  <Input>
    2
    2 3
    1 0
    1 0
    1 0 1
    4 6
    1 0 1 1 0
    0 1 0 0 1
    1 0 1 1 0
    0 0 0 0 1
    1 1 1 1 1 1
    1 1 1 1 1 1
    1 1 1 1 1 1
  </Input>
  {/* prettier-ignore */}
  <Output>
    1 0
  </Output>
</Examples>

## 예제 3

<Examples>
  {/* prettier-ignore */}
  <Input>
    1
    2 4
    0 1 1
    1 1 0
    1 1 1 0
  </Input>
  {/* prettier-ignore */}
  <Output>
    0
  </Output>
</Examples>

## 채점 방식

입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞추어야 그 종류에 배정된 점수를 받을 수 있다.

<Subtask index={1} score={20}>
  $N = M = 2$ 이다.
</Subtask>
<Subtask index={2} score={55}>
  세로무늬 값은 모두 $1$이다.(즉, 세로선은 모두 위로 볼록하다.)
</Subtask>
<Subtask index={3} score={125}>
  별다른 제약조건 없음.
</Subtask>

## 해설

<Solution>
  가장 마지막 접기로 가능한 것인지를 판단하는 것이 우선이다. 이 판단을 통해 가장
  마지막 접기로 가능한 것들을 찾고 나면 재귀적인 문제가 정의된다. 재귀적으로
  문제를 해결하면 종이의 크기가 작아지므로 적당한 시간 내에 해결하는 것이
  가능해진다.
</Solution>
