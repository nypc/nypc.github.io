<!DOCTYPE html>
<html>
<head>
    <title>
    </title>
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <style>
        h1 { margin-bottom: 20pt; font-size: 22pt; font-weight: bold; }
        h2 { margin-top: 20pt; font-size: 16pt; font-weight: bold; }
        h3 { margin-top: 20pt; font-size: 14pt; font-weight: bold; }
        blockquote { font-size: 11pt; }
        </style>
</head>
<body style='padding:20pt; font-family: 맑은 고딕;'>
<a href='./'>← 목록으로</a>
<hr>
<!--------------->
<h1 id="암호-해독-1519">암호 해독 (1519)</h1>
<p>로나와 판은 평소 통신할 때 문장을 암호화하여 통신한다.</p>
<p>이들이 쓰는 암호 알고리즘은 매우 단순한 것으로 흔히 치환 암호법이라고 불린다.</p>
<p>좀 더 자세히 설명하자면 26가지의 알파벳에 대해 치환되는 알파벳을 겹치지 않게 배치한 다음, 원래 문장에 있는 알파벳을 모두 치환하는 것이다.</p>
<p>26가지 알파벳에 대해 이러한 규칙을 적어놓은 것을 치환표라고 부른다.</p>
<p>예를 들어, 원래 문장 “Hello, world!”가 있다고 하면 이를 “Dpqqr, arzqb!”로 치환할 수 있다. 이때 사용되는 치환 규칙은 [h → d], [e → p], [l → q], [o → r], [w → a], [r → z], [d → b]이며 등장하지 않은 다른 알파벳에 치환되는 알파벳은 확인할 수 없다.</p>
<p><strong>단, [t → t]처럼 치환하기 전과 치환한 이후의 알파벳이 동일한 경우는 올바른 치환표라고 보지 않는다.</strong></p>
<p>원래 문장과 치환된 문장이 주어졌을 때, 가능한 알파벳 치환표를 가짓수를 출력한다.</p>
<p>아래 표는 위의 경우에서 가능한 치환표 중 한 가지이다.</p>
<figure style="text-align:center">
  <img src="https://nypc2019.s3.ap-northeast-2.amazonaws.com/cipher1.png">
  <figcaption>&lt;그림 1&gt; 치환표 예시</figcaption>
</figure>

<p>가능한 치환표가 하나도 없으면 0을 출력한다.</p>
<h2 id="입력-형식">입력 형식</h2>
<p>첫 번째 줄에 암호화하기 이전의 원래 문장이 주어진다.</p>
<p>두 번째 줄에 암호화한 이후의 치환된 문장이 주어진다.</p>
<p>각 줄에 주어지는 문자열은 공백을 포함한 특수문자 <code>&quot;&#39; .,!</code>와 알파벳 대소문자로 이루어져 있고, 길이는 최대 100이다. 문자열의 시작과 끝에 공백은 없으며 연속해서 두 개의 공백이 이어져서 주어지지도 않는다. 주어지는 두 문장의 길이는 같다.</p>
<p>원래 문장과 치환된 문장에서 특수문자는 항상 같은 위치에 같은 문자로 주어지며, 알파벳 대소문자 여부가 다르게 주어지지도 않는다.</p>
<h2 id="출력-형식">출력 형식</h2>
<p>로나와 판이 사용했다고 볼 수 있는 치환표의 가짓수를 출력한다. 단, 답이 매우 클 수 있으므로 1,000,000,007 (10<sup>9</sup>+7)로 나눈 나머지를 출력한다. 만약 가능한 치환표가 없는 경우 0을 출력한다.</p>
<h2 id="입력-예제-1">입력 예제 1</h2>
<pre><code>&quot;Hello, world!&quot;
&quot;Dpqqr, arzqb!&quot;</code></pre><h2 id="출력-예제-1">출력 예제 1</h2>
<pre><code>428402644</code></pre><h2 id="입력-예제-2">입력 예제 2</h2>
<pre><code>abcdefghijklmnopqrstuvwxyz
lusbpkmdevtqchrjfzywniaoxg</code></pre><h2 id="출력-예제-2">출력 예제 2</h2>
<pre><code>1</code></pre><h2 id="입력-예제-3">입력 예제 3</h2>
<pre><code>dog
dgo</code></pre><h2 id="출력-예제-3">출력 예제 3</h2>
<pre><code>0</code></pre><h2 id="채점-방식">채점 방식</h2>
<p>입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞추어야 그 종류에 배정된 점수를 받을 수 있다.</p>
<ul>
<li>종류 1 (26점): 암호화하기 이전의 원래 문장에서는 26가지 종류의 알파벳이 적어도 한 번은 등장한다.</li>
<li>종류 2 (74점): 별다른 제약조건 없음. </li>
</ul>
<!--------------->
<h2>해설</h2>
<p><button onclick='document.getElementById("hint_text").style.display="block"; this.style.display="none";' class='btn btn-default'>펼치기</button></p> 
<div id='hint_text' style='display: none;'> 
이 문제가 어려운 이유는 치환 전 문자와 치환 후 문자가 항상 달라야 하기 때문이다. DP를 이용해서 문제를 해결할 수 있다.
D[n][k]=아직 치환표에 값이 적히지 않은 알파벳 개수가 n개이며, 이 중 막 적었을 때 치환전과 치환후가 같을 가능성이 있는 알파벳 종류 수가 k개인 경우 가능한 치환표의 가지 수라고 정의할 수 있다.
만약 k=0인 경우 D[n][k] = D[n-1][k]*n 이다.
만약 k>0인 경우 D[n][k] = D[n-1][k-1]*(n-k) + D[n-1][k-2]*(k-1) 이다.
이와 같은 점화식으로 D[n][k]를 구하여 문제를 해결할 수 있다.     
</div> 
</body>
</html>