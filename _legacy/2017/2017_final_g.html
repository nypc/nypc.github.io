<!DOCTYPE html>
<html>
<head>
	<title>
	</title>
	<meta name="viewport" content="width=device-width" />
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
	<style>
		h1 { margin-bottom: 20pt; font-size: 22pt; font-weight: bold; }
		h2 { margin-top: 20pt; font-size: 16pt; font-weight: bold; }
		h3 { margin-top: 20pt; font-size: 14pt; font-weight: bold; }
		blockquote { font-size: 11pt; }
		</style>
</head>
<body style='padding:20pt; font-family: 맑은 고딕;'>
<a href='./'>← 목록으로</a>
<hr>

<h1>길드</h1>

<p>어떤 게임에 N명의 사용자들이 있다. 이 사용자들은 친구 관계를 맺고 있는데, 친구 관계인 쌍의 개수가 정확히 N-1이라고 한다. 또, 어떤 두 사용자를 보더라도 한번 이상의 친구 관계로 연결이 되어 있다고 한다. 각 사용자는 실력 값을 가지고 있다. 실력 값은 정수 값이다. 실력 값은 음수가 될 수도 있음에 주의하라.</p>

<p><img src="images/1508666684492_pic1.png" alt="그림 1"/></p>

<p>위 그림은 8명의 사용자와 그 친구 관계, 그리고 각 사용자의 실력 값을 보여 준다. 사용자들은 길드를 만들 수 있는데, 길드는 1명 이상의 사용자를 포함해야 한다. 또, 같은 길드에 포함된 두명의 사용자는 길드에 포함된 사용자들 간의 친구 관계 한번 이상으로 연결이 되어 있어야 한다. 길드의 실력 값은 길드에 포함된 사용자들의 실력 값의 합이다.</p>

<p>위의 상황에서 가장 실력 값이 큰 길드를 만드는 방법은 실력 값이 3과 2인 두 사용자가 길드를 만드는 방법이다. 이 경우 길드의 실력 값은 5가 된다. 물론 실력 값이 5인 사용자 혼자 길드를 만들어도 같은 실력 값을 가진다.</p>

<p>그림에서 제일 위쪽의 실력 값이 -4인 사용자의 실력이 3으로 증가했다고 하자. 그렇다면 이제는 4명의 사용자가 모여서 실력 값이 9인 길드를 만들 수 있다. 이 상태에서 왼쪽 아래의 실력 값이 2인 사용자의 실력이 5로 증가했다고 하면, 6명의 사용자가 모여서 실력 값이 10인 길드를 만들 수 있다.</p>

<p>사용자들의 친구 관계, 초기 실력 값과 실력 값이 증가하는 상황들을 입력 받아 모든 상황에서 가장 실력 값이 큰 길드를 만드는 방법을 출력하는 프로그램을 작성하라.</p>

<h2>입력 형식</h2>

<p>첫째 줄에 사용자의 수를 나타내는 자연수 N이 주어진다. (1 ≤ N ≤ 100,000) 사용자들은 1번부터 N번까지 번호가 붙어 있다. 다음 줄에 1번 사용자부터 순서대로 실력 값이 N개 주어진다. 실력 값은 -10<sup>9</sup>이상 10<sup>9</sup>이하의 정수이다. 다음 N-1개의 줄에 친구 관계인 사용자들의 번호 쌍이 주어진다. 그 다음 줄에 변화의 개수 U가 주어진다. (0 ≤ U ≤ 100,000) 다음 U개의 줄에 사용자의 실력 변화가 주어진다. 한 변화는 사용자 번호 n과, 증가값 v의 쌍이다. 번호가 n인 사용자의 실력 값이 v만큼 더해진다는 뜻이다. 이 때, v는 1이상 10<sup>9</sup>이하인 자연수이다.</p>

<h2>출력 형식</h2>

<p>출력은 U+1개의 줄로 구성된다. 첫 줄에는 초기 상태에서 만들 수 있는 가장 실력 값이 높은 길드의 실력 값을 출력한다. 다음 줄부터 각 변화가 적용된 후에 만들 수 있는 가장 실력 값이 높은 길드의 실력 값을 출력한다. 변화는 중첩되어 적용됨에 주의하라.</p>

<h2>입력 예제</h2>


<pre>
8
1 -4 3 2 2 -4 -6 5
1 2
2 3
3 4
3 6
6 5
3 7
8 7
2
2 7
5 3
</pre>


<h2>출력 예제</h2>


<pre>
5
9
10
</pre>


<h2>채점 방식</h2>

<p>입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞추어야 그 종류에 배정된 점수를 받을 수 있다.</p>

<ul>
    <li>종류1 (10점): U = 0이고, 각 사람의 친구 수는 2명을 넘지 않는다.</li>
    <li>종류2 (20점): N ≤ 1,000, U ≤ 1,000</li>
    <li>종류3 (40점): 각 사람의 친구 수는 2명을 넘지 않는다.</li>
    <li>종류4 (50점): 문제의 원래 제한조건 이외의 추가된 제한이 없음.</li>
</ul>

<h2>해설</h2>

<p><button onclick='document.getElementById("hint_text").style.display="block"; this.style.display="none";' class='btn btn-default'>펼치기</button></p>

<div id='hint_text' style='display: none;'>
다음과 같은 동적 계획법을 생각해볼 수 있다. D[i] = i가 루트인 서브트리에서 i를 포함한 실력 값이 가장 큰 길드의 크기. 사람들의 실력값이 변할 때마다 D[i] 값을 잘 관리해주면 되는데 이는 경로압축, 구간트리, Heavy-Light Decomposion을 이용해 빠른 시간안에 할 수 있다.
</div>


</body></html>