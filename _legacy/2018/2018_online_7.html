<!DOCTYPE html>
<html>
<head>
    <title>
    </title>
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <style>
        h1 { margin-bottom: 20pt; font-size: 22pt; font-weight: bold; }
        h2 { margin-top: 20pt; font-size: 16pt; font-weight: bold; }
        h3 { margin-top: 20pt; font-size: 14pt; font-weight: bold; }
        blockquote { font-size: 11pt; }
        </style>
</head>
<body style='padding:20pt; font-family: 맑은 고딕;'>
<a href='./'>← 목록으로</a>
<hr>
<!--------------->
<h1 id="-">최고의 동접 구간을 찾아라!</h1>
<p>게임 분석가 승민이는 넥슨의 게임 메이플스토리가 얼마나 인기가 높은지 알고 싶어졌다. 게임의 인기는 접속한 유저 수로 알 수 있고, 특히 동시에 몇 명의 유저가 접속해 있는지를 아는 것은 게임의 인기 뿐 아니라, 게임의 관리자 입장에서도 얼마나 많은 자원을 투자해야 하는지 중요한 자료가 된다.  따라서 승민이는 가장 많은 유저들이 동시에 접속한 구간을 손쉽게 찾아내고 싶다. </p>
<p>넥슨은 승민이에게 유저들의 로그인 시간과 로그아웃 시간이 저장된 로그 파일을 제공했다. 여러분은 승민이를 도와서,  이 로그 파일을 이용하여 가장 많은 유저들이 동시에 접속한 구간을 찾아내는 프로그램을 작성하자.    </p>
<h2 id="-">입력 형식</h2>
<p>첫째 줄에 로그의 수  N (1 ≤ N ≤ 300,000)가 입력된다. </p>
<p>다음 N 줄에 유저 하나가 로그인한 시간과 로그아웃한 시간이 공백으로 구별되어 주어진다. </p>
<ul>
<li>시간은 24시간의 형태로 <code>hh:mm</code>, 즉 시:분의 형태로 항상 두 자리씩 주어진다. </li>
<li>로그인 시간은 로그아웃 시간보다 반드시 앞선 시간이며, 게임을 하는 동안 날짜가 바뀌는 경우는 없다. </li>
<li>hh=24인 경우는 없다. 로그아웃 시간이 00:00인 경우는 주어지지 않는다.</li>
</ul>
<h2 id="-">출력 형식</h2>
<p>가장 많은 유저가 동시에 접속한 기간을 찾아서, 먼저 이 기간에 로그인한 유저의 수를 출력한다. 다음, 이 기간의 시작 시간과 종료 시간을 각각 24시간의 형태로 <code>hh:mm</code>, 즉 시:분의 형태로 출력한다. 만약 이러한 기간이 둘 이상 있다면, 가장 먼저 시작한 기간을 출력한다. </p>
<h2 id="-1">입력 예제 1</h2>
<pre><code>5
09:00 11:20
11:00 13:50
12:00 15:00
13:00 16:20
15:50 18:45 </code></pre><h2 id="-1">출력 예제 1</h2>
<pre><code>3
13:00 13:50</code></pre><h2 id="-2">입력 예제 2</h2>
<pre><code>2
09:00 09:59
10:00 11:00 </code></pre><h2 id="-2">출력 예제 2</h2>
<pre><code>1
09:00 09:59</code></pre><h2 id="-3">입력 예제 3</h2>
<pre><code>3
01:00 08:00
02:00 03:00
03:00 05:00  </code></pre><h2 id="-3">출력 예제 3</h2>
<pre><code>2
02:00 05:00</code></pre><p>입출력 예제 3번의 풀이를 보다 자세히 설명하면, 다음과 같다. </p>
<ul>
<li>1시부터 2시 직전까지는 1명의 유저가 로그인해 있다. </li>
<li>2시가 되면 1명의 유저가 추가로 로그인하여 동시 접속한 유저의 수는 총 2명이다. </li>
<li>이제 3시가 되면 1명의 유저가 로그아웃하는 <em>동시에</em> 다른 1명의 유저가 로그인하므로 동시 접속한 유저의 수는 <em>계속해서</em> 2명이다. 한 유저가 로그아웃하기 전 다른 유저가 로그인해서 동시 접속한 유저의 수가 3명이 되는 기간이 있거나, 한 유저가 로그아웃해서 동시 접속한 유저의 수가 1명이 된 다음 다른 유저가 로그인해서 동시 접속한 유저의 수가 다시 2명이 되는 것이 아님에 유의하시오. 따라서, 동시 접속한 유저의 수가 2명인 기간은 2시부터 5시 직전까지이다. </li>
<li>5시가 되면 1명의 유저가 로그아웃하여 동시 접속한 유저 수가 1명이 된다.  </li>
</ul>
<h2 id="-">채점 방식</h2>
<p>입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞추어야 그 종류에 배정된 점수를 받을 수 있다.</p>
<ul>
<li>종류1 (10점): N ≤ 2</li>
<li>종류2 (40점): N ≤ 5,000</li>
<li>종류3 (50점): 문제의 원래 제한조건 이외의 추가된 제한이 없음.  </li>
</ul>


<!--------------->
<h2>해설</h2>
<p><button onclick='document.getElementById("hint_text").style.display="block"; this.style.display="none";' class='btn btn-default'>펼치기</button></p> 
<div id='hint_text' style='display: none;'> 
사용자들의 로그인/로그아웃 시점을 받아 동접자가 가장 많았던 구간을 찾아야 한다. 단순히 모든 시점을 계산하여도 해결할 수 있으나, 입력 받은 시점들을 정렬하고 동접자 수를 시간이 진행되는 순서대로 계산하는 방법을 쓰면 더 빠르게 답을 알아낼 수 있다
</div> 
</body>
</html>