<!DOCTYPE html>
<html>
<head>
    <title>
    </title>
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <style>
        h1 { margin-bottom: 20pt; font-size: 22pt; font-weight: bold; }
        h2 { margin-top: 20pt; font-size: 16pt; font-weight: bold; }
        h3 { margin-top: 20pt; font-size: 14pt; font-weight: bold; }
        blockquote { font-size: 11pt; }
        </style>
</head>
<body style='padding:20pt; font-family: 맑은 고딕;'>
<a href='./'>← 목록으로</a>
<hr>
<!--------------->
<h1 id="flood-it">Flood-it</h1>
<p>Flood-it은 다음과 같은 규칙을 갖는 게임이다. 이 문제를 풀기 전에, 실제로 게임을 해보고 싶다면 <a href="https://unixpapa.com/floodit/">https://unixpapa.com/floodit/</a>에서 할 수 있다.</p>
<p>게임의 규칙은 다음과 같다. 가로 N 줄, 세로 N 열   N x N으로 이루어진 격자가 있다. 격자의 각 칸에는 10가지 색 중 하나가 칠해져 있다. 색깔이 같고, 위, 아래, 왼쪽, 오른쪽 중 하나로 바로 인접한 두 칸은 한 덩어리로 생각하자. 이런 식으로 생각하면 한 덩어리로 생각할 수 있는 칸은 두 칸 이상이 될 수 있다. 이제 매번 가장 왼쪽 위 칸의 색깔을 바꿀 수 있다. 이 칸의 색깔이 바뀌면, 이 칸과 같은 덩어리에 있는 칸들의 색깔이 모두 바뀐다. </p>
<p><img src="https://s3.ap-northeast-2.amazonaws.com/nypc2018/flood-it.png" alt="flood-it"></p>
<p>위 그림은 5 x 5 크기 격자로 주어진 Flood-it 게임의 예이다. 각 칸의 색깔은 숫자로도 표현되어 있다. </p>
<ul>
<li>처음 가장 왼쪽 위 칸의 색은 1이며, 바로 아래 칸과 한 덩어리를 이룬다. </li>
<li>이제 이 칸의 색을 1에서 2로 바꾸면, 같은 덩어리에 있는 칸들의 색이 모두 1에서 2로 바뀐다. 이 과정에서, 색이 원래 2이던 칸 하나가 새롭게 덩어리에 추가된다. </li>
<li>다시 가장 왼쪽 위 칸의 색을 3으로 바꾸면, 같은 덩어리에 있던 칸들의 색이 모두 2에서 3으로 바뀐다. 이 과정에서 색이 원래 3이던 칸 셋이 새롭게 덩어리에 추가된다. </li>
<li>마지막으로, 가장 왼쪽 위 칸의 색을 4로 바꾸면, 같은 덩어리에 있던 칸들의 색이 모두 3에서 4로 바뀐다. 이 과정에서 색이 원래 4이던 칸 둘이 새롭게 덩어리에 추가된다. </li>
</ul>
<p>Flood-it 게임의 목적은 색깔을 바꾸는 횟수를 최소화하여 전체 칸들의 색깔을 모두 같게 하는 것이다. </p>
<p>가장 왼쪽 윗 칸의 색깔의 변화 정보가 주어졌을 때, 이 순서대로 색깔을 바꾸고 난 뒤, 가장 왼쪽 위 칸과 한 덩어리인 칸 수를 구하는 프로그램을 작성하시오.</p>
<h2 id="-">입력 형식</h2>
<p> 첫째 줄에 격자의 크기를 나타내는 자연수 N과 가장 왼쪽 위 칸의 색깔이 바뀌는 횟수 K가 주어진다 (1 ≤ N ≤ 1,000, 0 ≤ K ≤ 1,000). 만약 K가 0이 아니라면, 바로 다음 줄에는 K 개의 0 이상 9 이하의 정수가 주어지는데, 이는 차례대로 가장 왼쪽 위 칸의 색이 이 정수가 나타내는 색깔로 변함을 의미한다. 각 칸에 올 수 있는 색깔이 10가지이므로 이렇게 표현할 수 있다. K가 0이라면 이 줄은 존재하지 않는다. 다음 N 줄에는 격자의 각 칸 색깔 정보가 주어진다. 격자를 위에서 아래로 읽었을 때 차례로, 한 줄에 하나씩 N개의 0 이상 9 이하 정수가 주어지는데, 이는 격자의 각 행을 왼쪽부터 오른쪽으로 읽어나갔을 때 각 칸의 색깔을 나타낸다.  </p>
<h2 id="-">출력 형식</h2>
<p>출력은 한 줄로 구성된다. 첫 줄에 가장 왼쪽 칸과 같은 덩어리에 속하는 칸 수를 출력한다. 칸 수를 셀 때 가장 왼쪽 윗 칸 자신도 포함됨에 주의하라.  </p>
<h2 id="-">입력 예제</h2>
<pre><code>5 3
2 3 4
1 3 2 3 3
1 2 1 5 3
4 3 6 3 1
1 3 4 2 3
1 5 1 3 5 </code></pre><h2 id="-">출력 예제</h2>
<pre><code>8</code></pre><h2 id="-">채점 방식</h2>
<p>입력 케이스들은 다음과 같은 종류로 구별되며, 한 종류의 케이스를 다 맞추어야 그 종류에 배정된 점수를 받을 수 있다.</p>
<ul>
<li>종류1 (10점):  K=0.</li>
<li>종류2 (70점):  N, K ≤ 100.</li>
<li>종류3 (70점): 문제의 원래 제한조건 이외의 추가된 제한이 없음.</li>
</ul>
<!--------------->
<h2>해설</h2>
<p><button onclick='document.getElementById("hint_text").style.display="block"; this.style.display="none";' class='btn btn-default'>펼치기</button></p> 
<div id='hint_text' style='display: none;'>
일단 N x N의 각 칸 하나가 원소인 집합들을 만든다. 다음, 가장 왼쪽 위 칸부터 시작하여, 가로/세로/위/아래로 인접한 칸들을 나타내는 집합들의 합집합을 구한다. 이 과정이 끝나면 같은 색의 연속한 칸들을 나타내는 서로소인 집합들을 만들 수 있으며, 두 집합에 대해서, 각각의 집합에 속하고 가로/세로/위/아래로 연속한 두 개의 칸이 있다면 이 집합도 서로 인접했다고 정의한다. 가장 왼쪽 위 칸의 색을 주어진 정보대로 바꿀 때마다, 이 칸이 속한 집합과 인접한 집합 중 같은 색인 것을 찾아 합집합을 구해 나가면 된다.    
</div> 
</body>
</html>